namespace dbarone_api.Lib.Data;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Data;
using System.Data.Common;
using System.Reflection;
using System.Collections;
using dbarone_api.Extensions;
using Microsoft.Data.SqlClient;

/// <summary>
/// Main session class for interacting with the database.
/// </summary>
public class Session : ISession
{
    private readonly string connectionString;
    private string provider;
    private Hydrater hydrater = new Hydrater();
    private int CommandTimeout = 30;

    /// <summary>
    /// Gets / sets the database connection.
    /// </summary>
    public IDbConnection Connection { get; set; }

    /// <summary>
    /// Gets / sets the database transaction.
    /// </summary>
    public IDbTransaction Transaction { get; set; }

    // static constructor (get entity information)
    static Session()
    {
        DbProviderFactories.RegisterFactory("Microsoft.Data.SqlClient", Microsoft.Data.SqlClient.SqlClientFactory.Instance);
        MetaDataStore.BuildMetaDataFor(typeof(Session).Assembly);
    }

    /// <summary>
    /// Builds the metaedata for the current Assembly.
    /// </summary>
    /// <param name="assembly"></param>
    public static void BuildMetaDataFor(Assembly assembly)
    {
        MetaDataStore.BuildMetaDataFor(assembly);
    }

    /// <summary>
    /// Creates a new session.
    /// </summary>
    /// <param name="connectionString"></param>
    /// <param name="commandTimeout"></param>
    /// <param name="providerName"></param>
    /// <returns></returns>
    public static ISession Create(string connectionString, int commandTimeout = 60, string providerName = "Microsoft.Data.SqlClient")
    {
        return new Session(
            providerName,
            connectionString,
            false,
            commandTimeout);
    }

    /// <summary>
    /// Disposes a session.
    /// </summary>
    public void Dispose()
    {
        if (Transaction != null) Transaction.Dispose();
        if (Connection != null) Connection.Dispose();
    }

    /// <summary>
    /// Commits the current transaction.
    /// </summary>
    public void Commit()
    {
        Transaction.Commit();
    }

    /// <summary>
    /// Performs a rollback of the current transaction.
    /// </summary>
    public void Rollback()
    {
        Transaction.Rollback();
    }

    /// <summary>
    /// Constructor for a new Session object.
    /// </summary>
    /// <param name="provider"></param>
    /// <param name="connectionString"></param>
    /// <param name="useTransaction"></param>
    /// <param name="commandTimeout"></param>
    public Session(string provider, string connectionString, bool useTransaction, int? commandTimeout = 30)
    {
        this.connectionString = connectionString;
        this.provider = provider;
        if (commandTimeout.HasValue) this.CommandTimeout = commandTimeout.Value;
        InitializeConnection(useTransaction);
    }

    /// <summary>
    /// Executes a SQL statement and returns a scalar value back.
    /// </summary>
    /// <param name="sql"></param>
    /// <param name="param"></param>
    /// <param name="commandType"></param>
    /// <param name="commandTimeout"></param>
    /// <returns></returns>
    public virtual object ExecuteScalar(string sql, object param = null, CommandType commandType = CommandType.Text, int? commandTimeout = null)
    {
        using (var cmd = BuildCommand(sql, param, commandType))
        {
            return cmd.ExecuteScalar();
        }
    }

    /// <summary>
    /// Executes a SQL select query and returns an array of entities back.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="sql"></param>
    /// <param name="param"></param>
    /// <param name="commandType"></param>
    /// <param name="buffered"></param>
    /// <returns></returns>
    public virtual IEnumerable<T> Query<T>(string sql = null, object param = null, CommandType commandType = CommandType.Text, bool buffered = true)
    {
        var data = QueryEntityInternal<T>(sql, param, commandType);
        return (buffered) ? data.ToList() : data;
    }

    /// <summary>
    /// Creates a new instance of an entity.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <returns></returns>
    public static T CreateEntity<T>()
    {
        return Activator.CreateInstance<T>();
    }

    private void ApplyAutoGeneratedValues<T>(T entity, bool isInsert = false, bool isUpdate = false)
    {
        var sequenceProps = entity.GetPropertiesDecoratedBy<AutoGeneratedAttribute>();
        foreach (var prop in sequenceProps)
        {
            var attr = prop.GetCustomAttribute<AutoGeneratedAttribute>();

            var sequence = attr!.SequenceName;
            var useCurrentDateTime = attr!.UseCurrentDateTime;
            var useCurrentUser = attr!.UseCurrentUser;
            var onInsert = attr!.OnInsert;
            var onUpdate = attr!.OnUpdate;
            var now = DateTime.Now;
            var currentUser = "dbarone";    //Thread.CurrentPrincipal.Identity.Name;

            if (!string.IsNullOrEmpty(sequence))
            {
                if ((isInsert & isInsert == onInsert) || (isUpdate & isUpdate == onUpdate))
                {
                    var next = (int)(long)this.ExecuteScalar($"SELECT NEXT VALUE FOR [{sequence}]");
                    prop.SetValue(entity, next);
                }
            }
            else if (useCurrentDateTime)
            {
                if ((isInsert & isInsert == onInsert) || (isUpdate & isUpdate == onUpdate))
                {
                    prop.SetValue(entity, now);
                }
            }
            else if (useCurrentUser)
            {
                if ((isInsert & isInsert == onInsert) || (isUpdate & isUpdate == onUpdate))
                {
                    prop.SetValue(entity, currentUser);
                }
            }
        }
    }

    /// <summary>
    /// Executes an INSERT statement to add a new entity to the database.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="entity"></param>
    public virtual object[] Insert<T>(T entity)
    {
        if (entity == null)
        {
            throw new Exception("Entity is null");
        }

        ApplyAutoGeneratedValues(entity, true, false);

        var info = MetaDataStore.GetTableInfoFor<T>();
        var columns = info.Columns.ToList().Where(c => c.DatabaseGenerated == false && c.IsMapped);
        var ht = GetParametersAsHashtableFor<T>(entity, columns);

        // Execute
        var sql = string.Format(
            "INSERT INTO [{0}] ({1}) SELECT {2}",
            info.Name,
            string.Join(",", columns.Select(c => $"[{c.Name}]")),
            string.Join(",", columns.Select(c => $"@{c.Name}"))
        );
        Execute(sql, ht);

        // Get record back
        return GetKeys<T>(entity);
    }

    public virtual IEnumerable<T> Read<T>(object? filter = null)
    {
        var ht = filter.ToHashTable();
        var info = MetaDataStore.GetTableInfoFor<T>();
        var filters = new List<string>();
        if (ht != null)
        {
            foreach (var item in ht.Keys) { filters.Add(item?.ToString()); }
        }

        // Execute
        var sql = string.Format(
            (ht != null) ? "SELECT * FROM [{0}] WHERE {1}" : "SELECT * FROM [{0}]",
            info.Name,
            string.Join(" AND ", filters.Select(f => string.Format("[{0}] = @{0}", f)))
        );
        return Query<T>(sql, ht);
    }

    /// <summary>
    /// Gets the keys for the object.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="obj"></param>
    /// <returns></returns>
    public object?[] GetKeys<T>(object obj)
    {
        List<object?> _keys = new();
        var info = MetaDataStore.GetTableInfoFor<T>();
        var columns = info.Columns.ToList();
        var keys = columns.Where(c => c.Key).OrderBy(c => c.Order).ToList();
        for (int i = 0; i < keys.Count(); i++)
        {
            _keys.Add(keys[i].PropertyInfo.GetValue(obj));
        }
        return _keys.ToArray();
    }

    /// <summary>
    /// Returns a single entity based on keys. If keys not found then exception thrown.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="keys"></param>
    /// <returns></returns>
    /// <exception cref="Exception"></exception>
    /// <exception cref="KeyNotFoundException"></exception>
    public virtual T Find<T>(params object[] keys)
    {
        Hashtable ht = new Hashtable();

        var info = MetaDataStore.GetTableInfoFor<T>();
        var columns = info.Columns.ToList();
        var parameters = keys.ToList();
        var keyColumns = columns.Where(c => c.Key).OrderBy(c => c.Order).ToList();
        if (parameters.Count() != keyColumns.Count())
        {
            throw new Exception("Cannot find entity. Incorrect number of key values passed in to method.");
        }

        // Get the parameters
        for (int i = 0; i < keyColumns.Count(); i++)
        {
            ht.Add(keyColumns[i].Name, parameters[i]);
        }

        // Execute
        var sql = string.Format(
            "SELECT * FROM [{0}] WHERE {1}",
            info.Name,
            string.Join(" AND ", keyColumns.Select(k => string.Format("[{0}] = @{0}", k.Name)))
        );

        var results = Query<T>(sql, ht);
        if (results.Count() == 0)
        {
            throw new KeyNotFoundException("Entity not found");
        }
        else if (results.Count() > 1)
        {
            throw new Exception("Duplicate entities found");
        }
        return results.First();
    }

    /// <summary>
    /// Similar to Read() method, but requires a single row to be returned, otherwise an exception is thrown.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="filter"></param>
    /// <returns></returns>
    /// <exception cref="Exception"></exception>
    public virtual T Single<T>(object? filter = null)
    {
        var results = Read<T>(filter);
        if (results.Count() != 1)
        {
            throw new Exception("Single() did not yield a single row.");
        }
        return results.First();
    }

    /// <summary>
    /// Updates an entity using the entity metadata.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="entity"></param>
    public virtual object[] Update<T>(T? entity)
    {
        if (entity == null)
        {
            throw new Exception("Error in Update() method. Entity cannot be null!");
        }

        ApplyAutoGeneratedValues(entity, false, true);

        var info = MetaDataStore.GetTableInfoFor<T>();
        var columns = info.Columns.ToList().Where(c => c.DatabaseGenerated == false && c.IsMapped && (c.AutoGeneratedAttribute ==null || (c.AutoGeneratedAttribute!=null && c.AutoGeneratedAttribute.OnUpdate)));
        var keyColumns = info.Columns.Where(c => c.Key).ToList();

        if (!keyColumns.Any())
        {
            throw new Exception("Cannot update Entity - no keys defined.");
        }

        var ht = GetParametersAsHashtableFor<T>(entity, columns.Union(keyColumns));

        // Execute
        var sql = string.Format(
            "UPDATE [{0}] SET {1} WHERE {2}",
            info.Name,
            string.Join(",", columns.Where(c => c.DatabaseGenerated == false).Select(c => string.Format("[{0}] = @{0}", c.Name))),
            string.Join(" AND ", keyColumns.Select(k => string.Format("[{0}] = @{0}", k.Name)))
        );
        Execute(sql, ht);

        // Get record back
        return GetKeys<T>(entity);
    }

    /// <summary>
    /// Deletes an entity using the entity metadata.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="entity"></param>
    public virtual void Delete<T>(T? entity)
    {
        if (entity == null)
        {
            throw new Exception("Error in Delete() method. Entity cannot be null!");
        }

        var info = MetaDataStore.GetTableInfoFor<T>();
        var keys = info.Columns.Where(c => c.Key).ToList();

        if (!keys.Any())
        {
            throw new Exception("Cannot delete Entity - no keys defined.");
        }

        // Get the parameters
        var ht = GetParametersAsHashtableFor<T>(entity, keys);

        // Execute
        var sql = string.Format(
            "DELETE FROM [{0}] WHERE {1}",
            info.Name,
            string.Join(" AND ", keys.Select(k => string.Format("[{0}] = @{0}", k.Name)))
        );
        Execute(sql, ht);
    }

    /// <summary>
    /// Return a list of Hashtable objects, reader is closed after the call
    /// </summary>
    public virtual IEnumerable<Hashtable> Query(string sql, object param = null, CommandType commandType = CommandType.Text, Action<List<string>> callbackHeaders = null)
    {
        using (var cmd = BuildCommand(sql, param, commandType))
        {
            bool processedHeader = false;
            using (var reader = cmd.ExecuteReader())
            {
                // Headers callback can be used for caller to do something
                // with header information. The hashtable returned
                // does not guarantee the order of the fields.
                if (!processedHeader && callbackHeaders != null)
                {
                    List<string> headers = new List<string>();
                    for (int i = 0; i < reader.FieldCount; i++)
                    {
                        headers.Add(reader.GetName(i));
                    }
                    callbackHeaders(headers);
                }
                while (reader.Read())
                    yield return hydrater.GetHashTable(reader);

                reader.NextResult();
            }
        }
    }

    public virtual int Execute(string sql, object param = null, CommandType commandType = CommandType.Text)
    {
        using (var cmd = BuildCommand(sql, param, commandType))
        {
            return cmd.ExecuteNonQuery();
        }
    }

    public IDataReader ExecuteReader(string sql, object param = null, CommandType commandType = CommandType.Text)
    {
        using (var cmd = BuildCommand(sql, param, commandType))
        {
            return cmd.ExecuteReader(CommandBehavior.SchemaOnly | CommandBehavior.KeyInfo | CommandBehavior.CloseConnection);
        }
    }

    public IEnumerable<Hashtable> GetSchema(string sql, object parameters = null, CommandType commandType = CommandType.Text)
    {
        using (var reader = ExecuteReader(sql, parameters, commandType))
        {
            //var sc = reader.GetSchemaTable();
            var schema_reader = reader.GetSchemaTable().CreateDataReader();
            bool hasIsHidden = false;

            for (int i = 0; i < schema_reader.FieldCount; i++)
                if (schema_reader.GetName(i).Equals("IsHidden", StringComparison.OrdinalIgnoreCase))
                    hasIsHidden = true;

            while (schema_reader.Read())
                // Only return columns in the output (ignore internal join columns not in SELECT)
                if (!hasIsHidden || schema_reader["IsHidden"] == null || (bool)schema_reader["IsHidden"] == false)
                    yield return hydrater.GetHashTable(schema_reader);
        }
    }

    public void BulkCopy(IEnumerable<Hashtable> data, Dictionary<string, Type> schema, string destination, int timeout = 60 * 60)
    {
        SqlBulkCopy bcp = new SqlBulkCopy(
            (SqlConnection)this.Connection,
            SqlBulkCopyOptions.Default,
            (SqlTransaction)this.Transaction);

        foreach (string column in schema.Keys)
            bcp.ColumnMappings.Add(column, column);

        bcp.DestinationTableName = destination;
        bcp.BulkCopyTimeout = timeout;

        HashtableDataReader adapter = new HashtableDataReader(data, schema);
        bcp.WriteToServer(adapter);

    }

    #region Private methods

    private IEnumerable<T> QueryEntityInternal<T>(string sql, object param = null, CommandType commandType = CommandType.Text, int? commandTimeout = null)
    {
        using (var cmd = BuildCommand(sql, param, commandType))
        {
            using (var reader = cmd.ExecuteReader())
            {
                while (reader.Read())
                    yield return hydrater.GetEntity<T>(reader);
            }
        }
    }

    private void InitializeConnection(bool createTransaction = true)
    {
        var factory = DbProviderFactories.GetFactory(provider);
        Connection = factory.CreateConnection();

        Connection.ConnectionString = connectionString;
        Connection.Open();
        if (createTransaction)
            Transaction = Connection.BeginTransaction();
    }

    private Hashtable GetParametersAsHashtableFor<T>(T entity, IEnumerable<ColumnInfo> columns)
    {
        Hashtable ht = new Hashtable();

        // Get the parameters
        foreach (var column in columns)
        {
            if (column.PropertyInfo.PropertyType.IsEnum && column.EnumColumnBehaviour == EnumColumnBehaviourEnum.STRING)
            {
                // TO DO: ADD THIS CODE TO UPDATE METHOD ETC.
                // If Enum + set to string format, output string representation
                var enumValue = (Enum)Convert.ChangeType(column.PropertyInfo.GetValue(entity), typeof(Enum));
                ht.Add(column.Name, enumValue.ToString());
            }
            else
                // otherwise, just the value.
                ht.Add(column.Name, column.PropertyInfo.GetValue(entity));
        }
        return ht;
    }

    private IDbCommand BuildCommand(string sql, object parameters = null, CommandType commandType = CommandType.Text)
    {
        if (Connection.State == ConnectionState.Closed)
            Connection.Open();

        var command = Connection.CreateCommand();
        command.Transaction = Transaction;
        command.CommandText = sql;
        command.CommandType = commandType;
        command.CommandTimeout = this.CommandTimeout;
        IDictionary<string, object> param_dict = new Dictionary<string, object>();

        // Parameters can either be passed in as an object, or as a Dyanamic
        if (parameters != null)
        {
            if (typeof(System.Dynamic.IDynamicMetaObjectProvider).IsAssignableFrom(parameters.GetType()))
            {
                // dynamic type
                if (parameters.GetType() == typeof(System.Dynamic.ExpandoObject))
                {
                    param_dict = (IDictionary<string, object>)parameters;
                }
            }
            else if (typeof(IDictionary).IsAssignableFrom(parameters.GetType()))
            {
                // dictionary
                var p = parameters as IDictionary;
                foreach (var item in p.Keys)
                {
                    param_dict.Add(item.ToString(), p[item]);
                }
            }
            else
            {
                foreach (PropertyInfo pi in parameters.GetType().GetProperties())
                {
                    param_dict.Add(pi.Name, pi.GetValue(parameters, null) ?? DBNull.Value);
                }
            }
        }

        // If stored proc used and connection is SqlServer, then automatically derive + populate the parameters
        var sqlcmd = command as SqlCommand;
        if (commandType == CommandType.StoredProcedure && sqlcmd != null)
        {
            SqlCommandBuilder.DeriveParameters(sqlcmd);
            foreach (SqlParameter param in sqlcmd.Parameters)
                if (param.Direction == ParameterDirection.Input || param.Direction == ParameterDirection.InputOutput)
                {
                    // the derived sql parameter names starts with '@' symbol.
                    string name = param.ParameterName.Substring(1);
                    if (param_dict.ContainsKey(name))
                    {
                        param.Value = param_dict[name];
                    }
                }
        }
        else
        {
            // otherwise, create + populate parameter
            foreach (var item in param_dict)
            {
                var p = command.CreateParameter();
                p.ParameterName = item.Key;
                p.Value = param_dict[item.Key] ?? DBNull.Value;
                command.Parameters.Add(p);
            }
        }
        return command;
    }

    #endregion
}
